---
title: 暗号の勉強をした
date: 2019-08-23 21:35:12 +0900
---

暗号の勉強をした
===

※まだ書き途中です。

タイトル通り、暗号の勉強をしたので自分なりにまとめてみる。

(追記)離散対数問題とか書き忘れてたので気が向いたら書く。

# 共通鍵暗号

共通の鍵を用いて暗号化する方法。
方法の1つにxor計算がある。というか僕はそれしか知らない。

とある数値に、別の数値を2回xor（排他的論理和）するともとに戻る、という性質。

($A \oplus B) \oplus B = A$

※$\oplus$はxor記号。

# 公開鍵暗号

暗号化と復号化に別の鍵を用いる暗号。

この中にも具体的には機能は複数あって、

- 任意の文字列を暗号化して届ける
- 鍵共有、つまり共有鍵を交換する

などがある。


特に前者の場合、相手の暗号鍵で暗号化し届けることで、復号鍵を持っている相手しか読めないように暗号化ができる。
このため暗号鍵を公開鍵、復号鍵を秘密鍵とも呼ぶ。

# 電子署名

署名技術。特定の人間によって確認されたデータだと証明できる。

署名鍵と検証鍵の２つが存在し、前者で署名、後者で検証できる。


>ちなみに、公開鍵暗号のうち、本来の
>
>「暗号鍵で暗号化して復号鍵で復号する」
>
>以外に、
>
>「復号鍵で暗号化して暗号鍵で復号化する」
>
>ことができる場合（RSA等）、自分が持っている復号鍵で暗号化することで電子署名として使うことができる。

# RSA暗号

RSA仮定は、RSA暗号やRSA署名で利用されている仮定。

まず適当な素数を２つ。pとqを生成する。

(安全に大きな素数を作り出す方法はよくわからないので気が向いたら調べる。)

pとqを掛け算する。pとqの掛け算した結果でmodした世界を考える。この積をnと呼ぼう。
例えばpとqを3と5にしよう。この場合、15がでてくる。
15でmodした世界は、0〜14が繰り返し出てくる世界になる。

このとき、p-1とq-1の積と、最大公約数が1になる数字を見つける。これをeと呼ぶ。（互いに素、と呼ぶらしい）
またp-1とq-1のmodの世界で、eにかけて1になる数字を見つける。これをdを呼ぶ。

$ed = 1 \mod (p-1)(q-1)$

ここで、オイラーの定理がでてくる。
互いに素な２つの数a,nがある。
nより小さいnと互いに素な数字の個数を見つけて、aをそれ乗してnでmodすると1になる。

$a^{((p-1)(q-1))}=1 (\mod n)$

ちなみにpqと互いな素な数字の個数は(p-1)(q-1)というのが知られてるらしい。

証明はよくわからなかったので飛ばす。

eとdの話に戻る。

pとqの積であるnでmodした世界で、秘密にしたいメッセージをe乗する。
これが暗号化になる。

$m^e \mod n$

暗号化したメッセージを、同じくmod nの世界でd乗するとmにもどる。

$(m^e)^d \mod n$

なぜなのか。

---

mをmod nの世界でde乗した。オイラーの公式を思い出すと、mod nの世界で、aをnと互いに素な数字の数乗すると1になる。

dとeの定義を思い出そう。

$ed = 1 \mod (p-1)(q-1)$

modの定義に帰ってると、この式はこう変形できる。

$(p-1)(q-1)×適当な数 + 1$。

特定の数で割った世界で、その数の倍数に1を足したものは、特定の数で割った世界で1になる。まあ当たり前のことだと思う。

よって、復号化の式はこう書ける。

$(m^e)^d \mod n$
↓
$m^{(p-1)(q-1)×適当な数 + 1} \mod n$。



指数関数の法則を使って指数部分をばらそう。

$m^{(p-1)(q-1)×適当な数}m^{1} \mod n$。

で、先頭部分はオイラーの公式により$1^x$になる。
つまり、結果mのみが残る。

## RSA署名

最初に記したように、RSA暗号の順番を入れ替えることで署名ができる。

# 楕円曲線

## 楕円曲線 DH鍵共有

楕円曲線暗号は、楕円曲線を使った暗号。

楕円曲線とは、具体的に以下のような等式をそう呼ぶ。

$y^2 = x^3 + ax + b \mod n$

この式や係数の具体的な数は事前に世界中で共有しておくこととする。

---

楕円曲線上で2点を通る直線を引く。そうするとその直線は他にもう一点と交わる。（重解、つまり接点の場合を除く）

このとき、2点から1点を計算するのは式に値を代入すれば良い。

この2点から1点を生み出す操作を、楕円曲線の上での演算と定義する。
その時、この演算は順序を変えてもなりたつし、また等式でつなげることもできる。
つまり、足し算と同じ性質を持つ。

なので、この演算を楕円曲線上での足し算と定義できる。C++でいう演算子オーバーライドだ。（整数同士ではなく楕円曲線上の点どうしの足し算）

で、更におもしろいことがある。足し算を繰り返すことを掛け算と呼ぶが、楕円曲線の上でも掛け算を定義できる。
ただ、それは足し算を一定回数繰り返すことのみなので、あくまで「点×定数」が計算できる。

たとえば$3 × G$は$G + G + G$となる。

---

上の事実を踏まえた上で、DH鍵共有を使う。通常のDH鍵共有はmod nの世界で指数法則を使うが、今回は肩に数字を乗っけるのではなく点を定数倍する。

---

アリスとボブで、それぞれ適当な数字aとbを作る。また事前に楕円曲線上の点Gを共有しておく。

お互い、$aG$と$bG$を作って公開・交換する。

相手からもらった$bG$、また$aG$に自分の持っているaまたはbを書けると、お互い$abG$が生成できる。これで共有鍵交換が完了する。

## 楕円曲線 DSA

こっちは署名をするアルゴリズムである。DSAを楕円曲線で行う。
通常のDSAは、
