---
title: "書式指定文字列攻撃について"
date: 2019-12-08 20:17:00 +0900
---

書式指定文字列攻撃について
===

この記事は、[onokatio Advent Calendar 2019](/adventcalendar/2019/onokatio) 8日目の記事です。

# printfと書式について

C言語には、`printf()`関数がある。


第一引数には、書式を含んだ文字列、つまりただの文字列と`%s`, `%d`等を組み合わせた文字列（のアドレス）を指定する。

第二引数以降には、書式文字列に渡すための変数を並べる。

```c
char a[] = "Hello World";
printf("%s", a);
```

=> `Hello World`


# 書式を外部から指定できる



```c
int b = 1;
char a[10];
scanf("%s", a);
printf(a);
```

例えば、これは入力された文字列をそのまま画面に出力する。

結果:

```shell
$ ./a.out
aaaaa <enter>
aaaaa
```


では、以下のような場合はどうなるか。

1.c
```c
int b = 12345;
char a[10];        ``
scanf("%s", a);
printf(a,b);
```

printfに、多めに引数をわたしたところで、書式文字列がなければ無視される。
では、このプログラムに`%d`と入力したらどうなるか?

そう、printfは文字列の中の書式に反応して、bの内容を出力してしまう。


では、printfの引数からbを除いたらどうか。


2.c
```c
int b = 12345;
char a[10];
scanf("%s", a);
printf(a);
```

よくわからない数字が出てくる、これはどういうことかというと。

Linuxでは、プログラムからメモリを扱う場合に、確保しているメモリ領域の任意の番地を使ってもいいいが、基本的にはスタックというデータ構造が扱われる。

スタックは、「データ列の末端にデータを追加する」「データの末端からデータを取り出す」の2つの行為が行える。

これにより、「スタックへ値を積み重ねてから関数を呼び出す」「呼び出された関数ではスタックからデータを指定された数分取り出して使う」ことで関数へ引数を渡すことができる。

printfは、引数がどれだけ指定されるか事前にわからないので、第一引数の中の書式指定文字列の分だけスタックから値を取り出して実行してしまう。

つまり、"%d"を入力した場合のprintf(a,b)実行直前には、スタックは以下のような状況になっており。


|上|
|:-:|
|a|
|b|
|?|
|下|

実行時には、まず一番上のaを取り出し、その中に書式指定文字列が1つしか無いため、その次のbをスタックから取り出し数値として表示する。

では、スタックに積んだ変数の数以上に書式指定文字列を指定したらどうなるか。

```shell
$ gcc -O0 -fno-stack-protector ./2.c
$ ./a.out
%x,%x,%x,%x,%x,%x,%x
a,0,0,ffffff80,40,7825aae0,252c7825
```

スタックの下の方の領域を表示できる。

おそらく、他の部分で使用している変数の中身が表示されている。

# taskctfの書式指定文字列攻撃を解いてみる

```c
#include <stdio.h>

char s3cr37[64] = "taskctf{XXXXXXXX}\0";

void get_flag(){
  printf("flag is %s\n", s3cr37);
}

int main(){
  char local[128];
  fgets(local,128,stdin);
  printf(local);
  printf("secret address: 0x%x\n", &s3cr37);
  return 0;
}
```

これを、実行すると。

```shell
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
$ ./a.out
%x,%x,%x,%x,%x,%x
666f2a1,0,666f2b2,61b97240,40,252c7825
secret address: 0x55558060
```

スタックの1番目はおそらくlocalのアドレス、6番目がlocalが実際に保存されている場所、ということがわかる。
"252c7825"をasciiコードとして文字に治すと "%x,"。

また、s3cr37のアドレスが`0x55558060`とわかるの。

ここから、攻撃する手立てを考える。

1. スタックに、localのアドレスを書き込む
2. そのアドレスが書き込まれたスタックをprintfにわたして、`%s`を指定すれば、そのアドレスから始まる文字列を`\0`が出てくるまで文字として表示させる

ということで、以下を入力します。

```shell
$ printf '\x60\x80\x55\x55 %5s' | ./a.out
taskctf{XXXXXXXX}
```


1. `\x60\x80\x55\x55` localの先頭4バイトにアドレスを書き込む
2. %5$n 5番めのアドレスの先ににある文字列を出力する


|上|
|:-:|
|localのアドレス|
|?|
|?|
|?|
|local (`\x60\x80\x55\x55 %5s`  = s3crc7のアドレスに見える)|
|?|
|?|
|?|
|s3crc7|
|下|


実はこうではない。Linuxはリトルエンディアン（上位ビットから順に詰める）

|上|
|:-:|
|localのアドレス|
|?|
|?|
|?|
|local下位 `%5s`|
|local上位 (`\x60\x80\x55\x55` = s3crc7のアドレスに見える)|
|?|
|?|
|s3crc7|
|下|

ということで、フラグが出てくるはずです（なぜはず、かというと、自分の環境で再現性がなかったため）

# 書き込み %n


printfには、`%n`書式がある。これはアドレスに今まで出力した文字列を書き込む。

```c
int hoge = veryImportantNumber;
char input[100];
scanf("%s",input)
printf(input)
```

ここで、`\x12\x34\x56\x78 %9999c %4$n`を入力すると…。

|上|
|:-:|
|inputのアドレス|
|?|
|?|
|?|
|input (`\x12\x34\x56\x78 %9999c %4$n` = hogeのアドレスに見える)|
|?|
|?|
|?|
|hoge|
|下|

- `\x12\x34\x56\x78` inputの先頭4バイトにアドレスを書き込む
- %9999c文字を9文字出力する
- %4$n 4番めのアドレスの先に出力した文字数99999(10進数)を書き込む

# まとめ

- 手元で動かせなかったのが悔しかった（Linuxのカーネル防御・gccのコンパイラオプションの問題だと思われ）
- 書式指定文字列攻撃は、オーソドックスだがCTFで結構出る
- CTF楽しいので是非参加してみてね
